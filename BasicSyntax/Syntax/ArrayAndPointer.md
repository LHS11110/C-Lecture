# 배열 추가 설명
배열은 `메모리상에 일렬로 연속되어 존재`한다. 연속되어 존재한다는 것은 `배열의 원소끼리 서로 떨어져 있지 않다`는 것이다.
연산에서 배열은 사실 포인터와 다를게 없는데, `포인터 변수의 값은 주소를 가르키는 것`처럼 `배열 또한 주소를 가르킨다.`
배열과 포인터가 다른것이 있다면 추상적인 의미에서 `배열은 크기를 가지고 포인터는 주소를 가르키기만 한다는 것`일 뿐이다.
`인덱싱 연산`은 `자료형의 크기`에 따라 `주소에 대해 적절한 연산`을 취한다.
만약 8바이트 부동소수점 배열을 생성한다면 인덱싱 코드는 아래와 같이 진행된다.

```cpp
double arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
arr[0] = 0; // 이 코드는 다음과 같다. *(arr + 0) = 0
arr[1] = 1; // *(arr + 1) = 1
arr[2] = 1; // *(arr + 2) = 2
arr[3] = 1; // *(arr + 3) = 3
arr[4] = 1; // *(arr + 4) = 4
```

`위 코드의 주석에서는` 단순히 배열이 가르키는 주소에 정수형 값을 더하고 주소 접근 연산을 통해 원소에 접근한다. 하지만 실제 원소들은 8바이트마다 메모리에 할당되어 있기 때문에 단순히 더하면 안되고 `8이라는 값을 인덱스에 곱해줘야 한다.`
컴파일 과정에서는 이를 인식하고 자동으로 바꿔주기 때문에 디스어셈블러(역 어셈블러)를 통해 확인하면 인덱스값에 해당 자료형의 크기만큼을 곱한 후 주소에 더하여 접근한다. 어셈블리어에서의 인덱싱 연산 ```*(arr + index * datatype)```,
다시 한번 강조하지만 `자료형의 크기를 곱하는 이유`는 `자료형이 1바이트가 아닌 n바이트씩 차지`하기 때문이다.

```cpp
// 배열의 크기를 명시해주지 않아도 초기화에서 배열의 크기를 명시할 수 있다.
int arr[] = { 1, 2, 3 }; // 크기가 3인 int 배열
```
# 2차원 배열
배열의 배열 또한 가능한데 이것을 2차원 배열이라 한다.
`한번의 인덱싱`으로 `배열에 접근`하고 `또 한번의 인덱싱`으로 `원소에 접근`한다.

```cpp
int arr[2][2] = { { 1, 2 }, { 3, 4 } };
arr[0][0] = 2;
```

2차원 배열 또한 메모리상에 일렬로 존재하는데, 위 코드에서 확인할 수 있듯 ```{ { 1, 2 }, { 3, 4 } }```의 형태로 존재한다.
2차원 배열의 인덱싱은 아래와 같이 진행된다.

```
arr[0]은 *(arr + 0)와 같다. 여기서 반환되는 값은 주소값이다.
arr[1][1]은 *(*(arr + 1) + 1)와 같다. 여기서 반환되는 값은 원소값이다.
```

2차원 배열은 이중 포인터와 같은 변수로 취급되기 때문에 원소에 접근하려면 주소 접근 연산 ```*```을 2번 사용해야 한다.
어셈블리어에서의 2차원 배열 연산 ```*(*(arr + index1 * arr1_size * datatype) + index2 * datatype)```,
`arr1_size`는 1차원 배열의 원소 개수이다. 위 arr 배열 선언 코드에서는 `arr1_size`가 `2`이다.
# 포인터 배열
- 포인터를 단순히 나열한 것을 말한다.

```cpp
int* arr[3];
int* (arr[3]);
```

두 코드는 같은 자료형을 가진 배열을 선언한다. arr의 자료형을 결정할 때 배열 연산 ```[3]```이 먼저 온다. 때문에 해당 변수는 `int*`를 3개 담을 수 있는 배열이다.

```cpp
int* ptr1, * ptr2, * ptr3;

int* ptr_arr[3];
```

위 코드에서 볼 수 있듯 포인터를 3개 선언하는 것보다 포인터 배열을 만드는 것이 더 깔끔하다.
# 배열 포인터
- 배열을 가르키는 포인터, 일반적인 포인터와는 다르다. `1차원 배열의 포인터`는 단순한 `포인터`를 사용한다. 하지만 `2차원 이상부터`는 `배열 포인터`라는 개념이 필요하다.

```cpp
int (*ptr)[3];
```

일단 코드를 해석하면 ```1차원 배열의 원소 개수가 3개인 2차원 배열 포인터```를 의미한다.
위 코드에서는 ```*```연산자가 먼저 온다. 때문에 포인터이며 ```int [3]```와 같은 자료형의 주소를 가르키는 포인터이다.

```cpp
int arr[2][2] = { { 1, 2 }, { 3, 4 } };
int (*ptr)[2] = arr;
```

여기서 배열 포인터는 이중 포인터와 비슷하다는 것을 알 수 있다.
하지만 2차원 배열을 이중 포인터로 가르키려 하면 이중 포인터로는 인덱싱을 할 수 없다.
이유는 2차원 배열의 인덱싱 연산중 1차원 배열의 원소 개수인 arr1_size를 알 수 없기 때문이다.
이를 알 수 있게 해주는 것이 배열 포인터이다. 위처럼 ```[2]```를 명시하면 1차원 배열의 원소 개수가 2개인 2차원 배열 포인터를 의미하게 된다.
배열 포인터는 하위 배열의 크기를 명시하여 2차원 이상의 n차원 배열을 포인터로써 사용할 수 있는 자료형을 말한다.
# n차원 배열과 배열 포인터
2차원 배열뿐만 아니라 3차원, 4차원 배열 또한 가능하다. 아래는 3차원 배열 코드이다.

```cpp
// 정수형 3차원 배열
int arr[3][3][3] = {{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, {{10, 11, 12}, {13, 14, 15}, {16, 17, 18}}, {{19, 20, 21}, {22, 23, 24}, {25, 26, 27}}};
```

이를 가르키는 배열 포인터 또한 가능하다.

```cpp
int (*ptr)[3][3] = arr;
```

코드를 해석하면 2차원 배열의 원소 개수는 3개, 1차원 배열의 원소 개수도 3개인 3차원 배열 포인터를 의미한다.
이중 포인터로도 2차원 배열을 선언할 수 있는데, 이는 나중에 배울 동적 할당에서 다룬다.