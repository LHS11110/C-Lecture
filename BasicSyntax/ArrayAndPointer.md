# 배열 추가 설명
- 배열은 메모리상에 일렬로 연속되어 존재한다. 연속되어 존재한다는 것은 배열의 원소끼리 서로 떨어져 있지 않다는 것이다.
- 연산에서 배열은 사실 포인터와 다를게 없는데, 포인터 변수의 값은 주소를 가르키는 것처럼 배열 또한 주소를 가르킨다.
- 인덱싱 연산은 자료형의 크기에 따라 주소에 대해 적절한 연산을 취한다.
- 만약 8바이트 부동소수점 배열을 생성한다면 인덱싱 코드는 아래와 같이 진행된다.

```cpp
double arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
arr[0] = 0; // arr[0]은 다음과 같다. *(arr + 0)
arr[1] = 1; // *(arr + 1)
arr[2] = 1; // *(arr + 2)
arr[3] = 1; // *(arr + 3)
arr[4] = 1; // *(arr + 4)
```

- 위 코드에서는 단순히 배열이 가르키는 주소에 정수형 값을 더하고 주소 접근 연산을 통해 원소에 접근한다.
- 실제 원소들은 4바이트마다 메모리에 할당되어 있기 때문에 단순히 더하면 안되고 4라는 값을 곱해줘야 한다.
- 컴파일 과정에서 이를 인식하기 때문에 어셈블리어를 통해 확인하면 인덱싱을 하는 과정은 연산에 해당 자료형의 크기만큼을 곱한 후 접근한다.
- 어셈블리어에서의 인덱싱 연산 ```arr + index * datatype```
- 다시 한번 설명하지만 자료형의 크기를 곱하는 이유는 자료형이 1바이트가 아닌 8바이트씩 차지하기 때문이다.
# 2차원 배열
- 배열의 배열 또한 가능한데 이것을 2차원 배열이라 한다.
- 한번의 인덱싱으로 배열에 접근하고 또 한번의 인덱싱으로 원소에 접근한다.

```cpp
int arr[2][2] = { { 1, 2 }, { 3, 4 } };
arr[0][0] = 2;
```

- 2차원 배열 또한 메모리상에 일렬로 존재하는데, 위 코드에서 일렬로 존재할 수 있는 방법이 나와있다.
- 2차원 배열에 할당하려는 값이 메모리상의 구조와 일치한다. ```{ { 1, 2 }, { 3, 4 } }```
- 2차원 배열의 인덱싱은 아래와 같이 진행된다.

```
arr[0]은 *(arr + 0)와 같다.
arr[1][1]은 *(*(arr + 1) + 1)와 같다.
```

- 2차원 배열은 이중 포인터와 같은 변수로 취급되기 때문에 2차원 배열은 주소 접근 연산 *을 2번 사용한다.
# 포인터 배열
- 포인터를 단순히 나열한 것을 말한다.

```cpp
int* arr[3];
int* (arr[3]);
```

- 두 코드는 같은 자료형을 가진 변수를 선언한다.
- 위 코드에서 배열 연산 ```[3]```이 먼저 온다. 때문에 해당 변수는 int*를 3개 담을 수 있는 배열이다.
# 배열 포인터
- 배열을 가르키는 포인터, 일반적인 포인터로 배열을 가르키는 것과는 다르다.

```cpp
int (*ptr)[3];
```

- 위 코드에서는 * 연산자가 먼저 온다. 때문에 포인터를 의미하며 int [3]을 가진 자료형의 주소를 가르키는 포인터이다.
- 배열 포인터를 이해하기 위해서는 먼저 배열이 사실 하나의 포인터와 유사하다는 것을 알아야 한다.
- 배열 또한 포인터라고 한다면 위 코드는 이중 포인터가 된다. 이중 포인터란 포인터의 주소를 가르키는 포인터를 말한다.
- 배열과 포인터가 다른것이 있다면 추상적인 의미에서 배열은 크기를 가지고 포인터는 주소를 가르키기만 한다는 것일 뿐이다.

```cpp
int arr[2][2] = { { 1, 2 }, { 3, 4 } };
int (*ptr)[2] = arr;
```

- 여기서 배열 포인터는 이중 포인터와 비슷하다는 것을 알 수 있다.
- 하지만 2차원 배열을 이중 포인터로 가르키려 하면 이중 포인터로는 인덱싱을 할 수 없다.
- 이유는 [연산자](./Operator.md)에서 확인할 수 있다.